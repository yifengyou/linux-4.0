# current在内核中的前前后后

```
所有内容均为学习所用，若有权限要求，请联系清理，谢谢~
```

## 参考

* [张银奎-用调试器深挖Linux内核的霸王代码](https://www.bilibili.com/video/BV1rf4y1f7kM)

---

## 引子

![20220718_203958_29](image/20220718_203958_29.png)

![20220718_204144_11](image/20220718_204144_11.png)


* **函数声明不是一个原型** 错误
* C中规范写法，宏必须大写。但是内核中```current```不该是宏的却是宏而非变量

![20220718_204349_40](image/20220718_204349_40.png)

* 问题抛出，段子先行
* 很多C/C++高手不喜欢用宏

![20220718_204502_67](image/20220718_204502_67.png)

![20220718_204525_83](image/20220718_204525_83.png)

![20220718_204552_35](image/20220718_204552_35.png)

![20220718_204606_13](image/20220718_204606_13.png)

* 早期Linus写的，也确实是变量。

![20220718_204720_41](image/20220718_204720_41.png)

* 96年的时候就变成了宏

![20220718_204755_27](image/20220718_204755_27.png)

![20220718_204830_30](image/20220718_204830_30.png)

* Alan Cox 添加SMP多处理器支持的补丁，但是因为内核有超多current依赖，若要逐一修改不得累死人
* 当时虽然会累死人，现在应该会很要命。所以其实是早期代码遗留问题

![20220718_205008_84](image/20220718_205008_84.png)

![20220718_205031_31](image/20220718_205031_31.png)

![20220718_205041_86](image/20220718_205041_86.png)

![20220718_205351_96](image/20220718_205351_96.png)

![20220718_205628_81](image/20220718_205628_81.png)

## 内核中的进程、线程

![20220718_205812_40](image/20220718_205812_40.png)

![20220718_205840_57](image/20220718_205840_57.png)

* 进程中的mm，同一个进程的mm如果指向相同，则表示相同的地址空间，表示同一个进程，但是不同线程

![20220718_205928_41](image/20220718_205928_41.png)

## PerCPU变量引入


* 每个cpu都应该有一个current，表示当前处理器正在执行的进程
* 毫无疑问，每个CPU应该有一个flag变量，若共用则需要加锁访问，效率不高

![20220718_210209_66](image/20220718_210209_66.png)

* 每个CPU上电就会无脑运行

![20220718_210401_19](image/20220718_210401_19.png)

![20220718_210425_86](image/20220718_210425_86.png)

![20220718_210438_68](image/20220718_210438_68.png)

* 特殊数据区就叫percpu。这个区域有多大？很复杂
* 每个CPU读取自己的percpu变量区域

![20220718_210534_27](image/20220718_210534_27.png)

* 曾经的写法是把pcb信息放到栈中，访问栈的特定位置就能获取到PCB的位置
* 但是栈不安全，容易被安排

![20220718_210603_97](image/20220718_210603_97.png)

* arm是读取特殊区域。arm硬件是安排了percpu区域

![20220718_210751_10](image/20220718_210751_10.png)

* 对于x86, **关键** 每个CPU有自己的gs段
* 所有gs段的内容，都是当前CPU的percpu区域

![20220718_210836_49](image/20220718_210836_49.png)

* X86段机制比较古老，但是在percpu中一直在用


![20220718_211017_44](image/20220718_211017_44.png)

![20220718_211055_25](image/20220718_211055_25.png)

* arm架构。美国人做事不够精细，英国人却能做到
* arm引入了新的机制，叫TPIDR，替代段机制

![20220718_211138_66](image/20220718_211138_66.png)

![20220718_211300_84](image/20220718_211300_84.png)


![20220718_211352_63](image/20220718_211352_63.png) 











---
