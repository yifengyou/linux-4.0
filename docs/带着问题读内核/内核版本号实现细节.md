<!-- MDTOC maxdepth:6 firsth1:1 numbering:0 flatten:0 bullets:1 updateOnSave:1 -->

- [内核版本号实现细节](#内核版本号实现细节)   
   - [make kernelversion追踪](#make-kernelversion追踪)   
   - [maek kernelrelease追踪](#maek-kernelrelease追踪)   
      - [解析selocalversion](#解析selocalversion)   
   - [如何传递kernelrelease到内核中](#如何传递kernelrelease到内核中)   

<!-- /MDTOC -->
# 内核版本号实现细节

## make kernelversion追踪

![20220715_161336_14](image/20220715_161336_14.png)

```
KERNELVERSION = $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))$(EXTRAVERSION)

->
KERNELVERSION = $(VERSION) \
  $(if \
    $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)) \
    ) \
  $(EXTRAVERSION)
```

此处用到Makefile的if语句

```
$(if CONDITION,THEN-PART)
$(if CONDITION,THEN-PART[,ELSE-PART])
```

* VERSION=4
  - 若PATCHLEVEL不为空，则拼接.PATCHLEVEL
    - 若SUBLEVEL不为空，则拼接.SUBLEVEL

![20220715_161514_38](image/20220715_161514_38.png)


```
VERSION = 4     //主版本号
PATCHLEVEL = 0  //修补版本号
SUBLEVEL = 0    //次版本号
EXTRAVERSION =  //附加信息，一般默认为空，我们可以自己设置
KERNELVERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL).$(EXTRAVERSION)
```


## maek kernelrelease追踪

```
kernelrelease:
	@echo "$(KERNELVERSION)$$($(CONFIG_SHELL) $(srctree)/scripts/setlocalversion $(srctree))"
```

kernelrelease是在KERNELVERSION基础上增加字段


获取当前环境锁用的shell

```
# SHELL used by kbuild
CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
	  else if [ -x /bin/bash ]; then echo /bin/bash; \
	  else echo sh; fi ; fi)
```

![20220715_162621_44](image/20220715_162621_44.png)

如果用户没有设置KBUILD_SRC变量，则默认kernel顶层目录作为srctree

```
bash ./scripts/setlocalversion .
```

![20220715_162933_78](image/20220715_162933_78.png)

### 解析selocalversion

```
#!/bin/sh
#
# This scripts adds local version information from the version
# control systems git, mercurial (hg) and subversion (svn).
#
# If something goes wrong, send a mail the kernel build mailinglist
# (see MAINTAINERS) and CC Nico Schottelius
# <nico-linuxsetlocalversion -at- schottelius.org>.
#
#

usage() { # 显示帮助信息
	echo "Usage: $0 [--save-scmversion] [srctree]" >&2
	exit 1
}

scm_only=false
srctree=.
if test "$1" = "--save-scmversion"; then # 如果是  [srctree] [--save-scmversion] 则要炸
	scm_only=true
	shift
fi
if test $# -gt 0; then
	srctree=$1
	shift
fi
if test $# -gt 0 -o ! -d "$srctree"; then
	usage
fi

scm_version()
{
	local short
	short=false

	cd "$srctree"
	if test -e .scmversion; then
		cat .scmversion
		return
	fi
	if test "$1" = "--short"; then
		short=true
	fi

	# Check for git and a git repo.
	if test -z "$(git rev-parse --show-cdup 2>/dev/null)" &&
	   head=`git rev-parse --verify --short HEAD 2>/dev/null`; then

		# If we are at a tagged commit (like "v2.6.30-rc6"), we ignore
		# it, because this version is defined in the top level Makefile.
		if [ -z "`git describe --exact-match 2>/dev/null`" ]; then

			# If only the short version is requested, don't bother
			# running further git commands
			if $short; then
				echo "+"
				return
			fi
			# If we are past a tagged commit (like
			# "v2.6.30-rc5-302-g72357d5"), we pretty print it.
			if atag="`git describe 2>/dev/null`"; then
				echo "$atag" | awk -F- '{printf("-%05d-%s", $(NF-1),$(NF))}'

			# If we don't have a tag at all we print -g{commitish}.
			else
				printf '%s%s' -g $head
			fi
		fi

		# Is this git on svn?
		if git config --get svn-remote.svn.url >/dev/null; then
			printf -- '-svn%s' "`git svn find-rev $head`"
		fi

		# Check for uncommitted changes
		if git diff-index --name-only HEAD | grep -qv "^scripts/package"; then
			printf '%s' -dirty
		fi

		# All done with git
		return
	fi

	# Check for mercurial and a mercurial repo.
	if test -d .hg && hgid=`hg id 2>/dev/null`; then
		# Do we have an tagged version?  If so, latesttagdistance == 1
		if [ "`hg log -r . --template '{latesttagdistance}'`" == "1" ]; then
			id=`hg log -r . --template '{latesttag}'`
			printf '%s%s' -hg "$id"
		else
			tag=`printf '%s' "$hgid" | cut -d' ' -f2`
			if [ -z "$tag" -o "$tag" = tip ]; then
				id=`printf '%s' "$hgid" | sed 's/[+ ].*//'`
				printf '%s%s' -hg "$id"
			fi
		fi

		# Are there uncommitted changes?
		# These are represented by + after the changeset id.
		case "$hgid" in
			*+|*+\ *) printf '%s' -dirty ;;
		esac

		# All done with mercurial
		return
	fi

	# Check for svn and a svn repo.
	if rev=`LANG= LC_ALL= LC_MESSAGES=C svn info 2>/dev/null | grep '^Last Changed Rev'`; then
		rev=`echo $rev | awk '{print $NF}'`
		printf -- '-svn%s' "$rev"

		# All done with svn
		return
	fi
}

collect_files()
{
	local file res

	for file; do
		case "$file" in
		*\~*)
			continue
			;;
		esac
		if test -e "$file"; then
			res="$res$(cat "$file")"
		fi
	done
	echo "$res"
}

if $scm_only; then # 目前用的是gi，不会用到scm_only
	if test ! -e .scmversion; then
		res=$(scm_version)
		echo "$res" >.scmversion
	fi
	exit
fi

if test -e include/config/auto.conf; then
	. include/config/auto.conf  # 基本配置，否则就需要prepare一下
	# 把CONFIG_*作为环境变量
else
	echo "Error: kernelrelease not valid - run 'make prepare' to update it"
	exit 1
fi

# localversion* files in the build and source directory
res="$(collect_files localversion*)"
if test ! "$srctree" -ef .; then
	res="$res$(collect_files "$srctree"/localversion*)"
fi

# CONFIG_LOCALVERSION and LOCALVERSION (if set)
res="${res}${CONFIG_LOCALVERSION}${LOCALVERSION}"

# scm version string if not at a tagged commit
if test "$CONFIG_LOCALVERSION_AUTO" = "y"; then
	# full scm version string
	res="$res$(scm_version)"
else
	# append a plus sign if the repository is not in a clean
	# annotated or signed tagged state (as git describe only
	# looks at signed or annotated tags - git tag -a/-s) and
	# LOCALVERSION= is not specified
	if test "${LOCALVERSION+set}" != "set"; then
		scm=$(scm_version --short)
		res="$res${scm:++}"
	fi
fi

echo "$res" # 输出最终结果
```

忽略大部分，关注这里

```
# CONFIG_LOCALVERSION and LOCALVERSION (if set)
res="${res}${CONFIG_LOCALVERSION}${LOCALVERSION}"

# scm version string if not at a tagged commit
if test "$CONFIG_LOCALVERSION_AUTO" = "y"; then
	# full scm version string
	res="$res$(scm_version)"
else
	# append a plus sign if the repository is not in a clean
	# annotated or signed tagged state (as git describe only
	# looks at signed or annotated tags - git tag -a/-s) and
	# LOCALVERSION= is not specified
	if test "${LOCALVERSION+set}" != "set"; then
		scm=$(scm_version --short)
		res="$res${scm:++}"
	fi
fi

echo "$res"
```

* CONFIG_LOCALVERSION 在 include/config/autoconf 配置
* 建议修改成 CONFIG_LOCALVERSION_AUTO=y 另一种方式花里胡哨，当然你也可以在这里随意定制

![20220715_164212_77](image/20220715_164212_77.png)

![20220715_165340_86](image/20220715_165340_86.png)


一个版本号不应该过于花里胡哨，简单一点，版本+提交号就行了的。稍微改写一下
```
5.4.86-gd9c22b050bd1
```

![20220715_171322_48](image/20220715_171322_48.png)

调整一下，就很棒棒，开森

![20220715_172606_33](image/20220715_172606_33.png)

## 如何传递kernelrelease到内核中

![20220715_205340_14](image/20220715_205340_14.png)

内核启动的这个记录，是从哪里读取的？

先猜测一下，应该是个常量字符串。strings一下，很明显，那么是哪里定义，哪里打印的？

![20220715_205523_13](image/20220715_205523_13.png)

咱的内核版本是个变量，但是这个字符串名称开头多了**Linux version**，用这个字符串去检索，很容易定位到，是在version.c中定义，不信你改改重编译内核试试

![20220715_205942_13](image/20220715_205942_13.png)

![20220715_210129_83](image/20220715_210129_83.png)

修改一下，重新编译内核，花了我30s，你懂得，就是这里

![20220715_210121_78](image/20220715_210121_78.png)

来看看字段是怎么拼起来的，来，拆解一下

```
/* FIXED STRINGS! Don't touch! */
const char linux_banner[] =
	"Linux version " UTS_RELEASE " (" LINUX_COMPILE_BY "@"
	LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION "\n";

You@Linux version 4.0.0-localversion-db085bec (root@rocky-clion) (gcc version 8.5.0 20210514 (Red Hat 8.5.0-10) (GCC) ) #2 SMP Fri Jul 15 21:00:36 CST 2022 x86_64
```

1. UTS_RELEASE : version 4.0.0-localversion-db085bec
2. LINUX_COMPILE_BY : root
3. LINUX_COMPILE_HOST : rocky-clion
4. LINUX_COMPILER : (gcc version 8.5.0 20210514 (Red Hat 8.5.0-10) (GCC) )
5. UTS_VERSION :  #2 SMP Fri Jul 15 21:00:36 CST 2022 x86_64


![20220715_211432_84](image/20220715_211432_84.png)

虽然很多条高度类似的记录，但是这条太明显了吧。另外，其实你用vscode代码跳转也能到这里。

![20220715_211516_72](image/20220715_211516_72.png)

![20220715_211613_45](image/20220715_211613_45.png)

5个值全在这个目录，同样，目录也是够见名知意，你足够聪明，你就知道，这个目录里的内容应该就是编译前自动生成滴。那么是怎么生成滴呢？

猜一猜，kbuild、Makefile、Scripts说白了，他们执行流都是调用Shell命令去操作的，那么极有可能是某个重定向操作

![20220715_211959_10](image/20220715_211959_10.png)

来吧，聪明的你，从这条语句能看出啥。首先Makefile，开头是目标，那么将compile.h作为目标，毫无疑问，它执行语句就是要生成这个目标。

![20220715_212135_59](image/20220715_212135_59.png)

```
include/generated/compile.h: FORCE
	@$($(quiet)chk_compile.h)
	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/mkcompile_h $@ \
	"$(UTS_MACHINE)" "$(CONFIG_SMP)" "$(CONFIG_PREEMPT)" "$(CC) $(KBUILD_CFLAGS)"
```

这里拆解一下，应该是

```
/bin/bash $(srctree)/scripts/mkcompile_h include/generated/compile.h "$(UTS_MACHINE)" "$(CONFIG_SMP)" "$(CONFIG_PREEMPT)" "$(CC) $(KBUILD_CFLAGS)"
```

大致意思就是mkcompile_h根据``` "$(UTS_MACHINE)" "$(CONFIG_SMP)" "$(CONFIG_PREEMPT)" "$(CC) $(KBUILD_CFLAGS)" ```生成 ```include/generated/compile.h``` 文件


1. LINUX_COMPILE_BY : root
2. LINUX_COMPILE_HOST : rocky-clion
3. LINUX_COMPILER : (gcc version 8.5.0 20210514 (Red Hat 8.5.0-10) (GCC) )
4. UTS_VERSION :  #2 SMP Fri Jul 15 21:00:36 CST 2022 x86_64

注意：这里不包括 UTS_RELEASE

看看 scripts/mkcompile_h 代码：

![20220715_213432_30](image/20220715_213432_30.png)

首先 UTS_MACHINE ，既然是在Makefile那就脱离C代码，其实也是脚本，但是中途可能修改了N多回，大概看下可能存在的修改点就可以了

![20220715_214104_48](image/20220715_214104_48.png)

其实最开始顶层的Makefile已经有定义了，但后面可能在交叉编译的时候覆盖了

![20220715_214153_62](image/20220715_214153_62.png)

对于 CONFIG_SMP ， 这年头基本都是对称多处理器。SMP就代表硬件支持多核心

![20220715_214247_73](image/20220715_214247_73.png)

同样 CONFIG_PREEMPT 其实就是.config加载过来的，是否支持抢占

对于 CC 懂得都懂，就是编译器，不一定就是gcc也可能其他，但是统称CC。实际执行的命令是这个：

![20220715_215446_11](image/20220715_215446_11.png)

对于 KBUILD_CFLAGS ，因为make中途修改非常频繁，找到具体修改点没有意义的。

![20220715_214439_66](image/20220715_214439_66.png)

这几个参数打到 scripts/mkcompile_h 脚本里，就会输出 include/generated/compile.h

还有一个文件，include/generated/utsrelease.h 谁生成？字符检索大法搞起来，毫无疑问又是这里


![20220715_220004_42](image/20220715_220004_42.png)

![20220715_220032_37](image/20220715_220032_37.png)

![20220715_220220_61](image/20220715_220220_61.png)

![20220715_220435_57](image/20220715_220435_57.png)

![20220715_220850_21](image/20220715_220850_21.png)

![20220715_220954_93](image/20220715_220954_93.png)

这里涉及到了Makefile函数定义，依赖调用来调用去。说白了就是两个子任务，一个去生成KERNELRELEASE这个变量，另一个将变量拼凑成一个文本内容。

有一点很奇怪，为什么没有重定向到目标文件的操作，如果隐晦一点，也没找到，怎么回事呢？

```
echo XXX > $@
```

![20220715_221600_52](image/20220715_221600_52.png)

FORCE是个隐式规则，就是每次都重新执行。


## 总结

整个一套搞下来。你会发现，这些版本号，对应到C语言里就是预定义宏。但是生成过程，说到底就是make主导的bash命令的执行。



## 参考

* 你知道kernel version的实现原理和细节吗:<https://blog.csdn.net/weiqifa0/article/details/120558906>


---
